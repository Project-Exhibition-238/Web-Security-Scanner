import requests
import time
import urllib.parse
from bs4 import BeautifulSoup
import re
from concurrent.futures import ThreadPoolExecutor
import random

class VulnerabilityChecker:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SecurityScanner/1.0 (Vulnerability Assessment)'
        })
        self.timeout = 5  # Reduced timeout

    def _try_both_protocols(self, url):
        """Try both HTTP and HTTPS if one fails"""
        urls_to_try = []

        if url.startswith('https://'):
            urls_to_try = [url, url.replace('https://', 'http://')]
        elif url.startswith('http://'):
            urls_to_try = [url.replace('http://', 'https://'), url]
        else:
            # No protocol specified, try HTTPS first then HTTP
            urls_to_try = [f'https://{url}', f'http://{url}']

        for test_url in urls_to_try:
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200:
                    return response, test_url
            except Exception as e:
                print(f"Failed to connect to {test_url}: {e}")
                continue

        # If both fail, raise the last exception
        raise requests.exceptions.ConnectionError(f"Could not connect to {url} via HTTP or HTTPS")

    def scan(self, url):
        """Main scan method that orchestrates all vulnerability checks"""
        findings = []

        try:
            print(f"[DEBUG] Starting vulnerability scan for: {url}")

            # Step 1: Discover injection points
            injection_points = self.discover_injection_points(url)
            print(f"[DEBUG] Found {len(injection_points)} injection points")

            # Step 2: Run various vulnerability checks
            print("[DEBUG] Starting SQL injection tests...")
            sql_findings = self.check_sql_injection(url, injection_points)
            findings.extend(sql_findings)
            print(f"[DEBUG] SQL injection tests completed: {len(sql_findings)} findings")

            print("[DEBUG] Starting XSS tests...")
            xss_findings = self.check_xss_vulnerabilities(url, injection_points)
            findings.extend(xss_findings)
            print(f"[DEBUG] XSS tests completed: {len(xss_findings)} findings")

            print("[DEBUG] Starting command injection tests...")
            cmd_findings = self.check_command_injection(url, injection_points)
            findings.extend(cmd_findings)
            print(f"[DEBUG] Command injection tests completed: {len(cmd_findings)} findings")

            print("[DEBUG] Starting open redirect tests...")
            redirect_findings = self.check_open_redirect(url, injection_points)
            findings.extend(redirect_findings)
            print(f"[DEBUG] Open redirect tests completed: {len(redirect_findings)} findings")

        except Exception as e:
            print(f"[ERROR] Vulnerability scan error: {e}")
            findings.append({
                'severity': 'Info',
                'title': 'Vulnerability scan error',
                'description': f'Error during vulnerability scanning: {str(e)}'
            })

        # Always return at least one finding for debugging
        if not findings:
            findings.append({
                'severity': 'Info',
                'title': 'No Vulnerabilities Detected',
                'description': f'No vulnerabilities found during scan of {url}. This could mean the site is secure or the scanner needs tuning.'
            })

        print(f"[DEBUG] Total vulnerability findings: {len(findings)}")
        return findings

    def discover_injection_points(self, url):
        """Discover potential injection points by finding links with parameters and forms"""
        injection_points = []

        try:
            response, working_url = self._try_both_protocols(url)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Find links with parameters
            for link in soup.find_all('a', href=True):
                href = link['href']
                if '?' in href:
                    full_url = urllib.parse.urljoin(working_url, href)
                    parsed = urllib.parse.urlparse(full_url)
                    params = urllib.parse.parse_qs(parsed.query)

                    for param in params.keys():
                        injection_points.append({
                            'type': 'GET',
                            'url': full_url,
                            'parameter': param
                        })

            # Find forms
            for form in soup.find_all('form'):
                action = form.get('action', '')
                method = form.get('method', 'GET').upper()
                form_url = urllib.parse.urljoin(working_url, action)

                for input_field in form.find_all(['input', 'textarea', 'select']):
                    name = input_field.get('name')
                    if name:
                        injection_points.append({
                            'type': method,
                            'url': form_url,
                            'parameter': name,
                            'form': True
                        })

            # If no injection points found, test common parameters on the main URL
            if not injection_points:
                common_params = ['id', 'page', 'search', 'q', 'user', 'category', 'item']
                for param in common_params:
                    injection_points.append({
                        'type': 'GET',
                        'url': working_url,
                        'parameter': param
                    })

        except Exception as e:
            print(f"[ERROR] Error discovering injection points: {e}")

        return injection_points[:10]  # Limit to 10 points for performance

    def check_sql_injection(self, base_url, injection_points):
        """Check for SQL injection vulnerabilities using multiple techniques"""
        findings = []

        if not injection_points:
            return findings

        sql_payloads = {
            'error_based': ["'", "\\", '""', "';--", "' OR '1'='1'"],
            'boolean_based': ["' OR 1=1 --", "' OR 'a'='a", " OR 1=1 --"],
            'time_based': ["'; WAITFOR DELAY '00:00:03'--", "' OR SLEEP(3)--", "'; SELECT SLEEP(3)--"]
        }

        for point in injection_points[:3]:  # Limit testing points
            try:
                print(f"[DEBUG] Testing SQL injection on parameter: {point['parameter']}")
                original_response = self._make_request(point, "normal_value")

                # Test Error-based SQL Injection
                for payload in sql_payloads['error_based'][:2]:  # Limit payloads
                    try:
                        response = self._make_request(point, payload)
                        if self._detect_sql_errors(response.text):
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Error-based',
                                'description': f'Error-based SQL injection detected in parameter "{point["parameter"]}" using payload: {payload}'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing SQL payload {payload}: {e}")
                        continue

                # Test Boolean-based SQL Injection
                for payload in sql_payloads['boolean_based'][:2]:  # Limit payloads
                    try:
                        response = self._make_request(point, payload)
                        if abs(len(response.text) - len(original_response.text)) > 100:  # Significant difference
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Boolean-based',
                                'description': f'Boolean-based SQL injection detected in parameter "{point["parameter"]}" - response differs with payload: {payload}'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing boolean SQL payload {payload}: {e}")
                        continue

                # Test Time-based SQL Injection (shorter delay)
                for payload in sql_payloads['time_based'][:1]:  # Test only one time-based payload
                    try:
                        start_time = time.time()
                        response = self._make_request(point, payload)
                        elapsed_time = time.time() - start_time

                        if elapsed_time > 2.5:  # Reduced threshold
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Time-based',
                                'description': f'Time-based SQL injection detected in parameter "{point["parameter"]}" - response delayed by {elapsed_time:.2f} seconds'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing time-based SQL payload {payload}: {e}")
                        continue

            except Exception as e:
                print(f"[DEBUG] Error testing SQL injection on point {point}: {e}")
                continue

        return findings

    def check_xss_vulnerabilities(self, base_url, injection_points):
        """Check for Cross-Site Scripting vulnerabilities"""
        findings = []

        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            '<img src=x onerror=alert("XSS")>'
        ]

        for point in injection_points[:3]:
            try:
                print(f"[DEBUG] Testing XSS on parameter: {point['parameter']}")
                for payload in xss_payloads[:2]:  # Limit payloads
                    response = self._make_request(point, payload)

                    # Check if payload is reflected in response
                    if payload in response.text or payload.replace('"', "'") in response.text:
                        # Check if it's properly escaped
                        if not self._is_xss_escaped(response.text, payload):
                            findings.append({
                                'severity': 'High',
                                'title': 'Cross-Site Scripting (XSS)',
                                'description': f'Reflected XSS vulnerability found in parameter "{point["parameter"]}" - payload reflected without proper escaping'
                            })
                            break

            except Exception as e:
                print(f"[DEBUG] Error testing XSS on point {point}: {e}")
                continue

        return findings

    def check_command_injection(self, base_url, injection_points):
        """Check for OS command injection vulnerabilities"""
        findings = []

        command_payloads = [
            '; ls -la',
            '| whoami',
            '`id`',
            '; ping -c 1 127.0.0.1'
        ]

        for point in injection_points[:2]:
            try:
                print(f"[DEBUG] Testing command injection on parameter: {point['parameter']}")
                for payload in command_payloads[:2]:  # Limit payloads
                    response = self._make_request(point, payload)

                    # Look for command output indicators
                    if self._detect_command_output(response.text):
                        findings.append({
                            'severity': 'Critical',
                            'title': 'OS Command Injection',
                            'description': f'Command injection vulnerability detected in parameter "{point["parameter"]}" - system command output found in response'
                        })
                        break

            except Exception as e:
                print(f"[DEBUG] Error testing command injection on point {point}: {e}")
                continue

        return findings

    def check_open_redirect(self, base_url, injection_points):
        """Check for open redirect vulnerabilities"""
        findings = []

        redirect_payloads = [
            'http://evil.com',
            'https://malicious.site',
            '//evil.com'
        ]

        for point in injection_points[:2]:
            try:
                print(f"[DEBUG] Testing open redirect on parameter: {point['parameter']}")
                for payload in redirect_payloads:
                    response = self._make_request(point, payload, allow_redirects=False)

                    # Check for redirect responses
                    if response.status_code in [301, 302, 307, 308]:
                        location = response.headers.get('Location', '')
                        if payload in location or 'evil.com' in location:
                            findings.append({
                                'severity': 'Medium',
                                'title': 'Open Redirect',
                                'description': f'Open redirect vulnerability found in parameter "{point["parameter"]}" - redirects to external site: {location}'
                            })
                            break

            except Exception as e:
                print(f"[DEBUG] Error testing open redirect on point {point}: {e}")
                continue

        return findings

    def _make_request(self, injection_point, payload, allow_redirects=True):
        """Make HTTP request with payload and protocol fallback"""
        try:
            if injection_point['type'] == 'GET':
                parsed_url = urllib.parse.urlparse(injection_point['url'])
                params = urllib.parse.parse_qs(parsed_url.query)
                params[injection_point['parameter']] = [payload]

                new_query = urllib.parse.urlencode(params, doseq=True)
                new_url = urllib.parse.urlunparse((
                    parsed_url.scheme, parsed_url.netloc, parsed_url.path,
                    parsed_url.params, new_query, parsed_url.fragment
                ))

                return self.session.get(new_url, timeout=self.timeout, allow_redirects=allow_redirects)

            else:  # POST request
                data = {injection_point['parameter']: payload}
                return self.session.post(injection_point['url'], data=data, timeout=self.timeout, allow_redirects=allow_redirects)

        except requests.exceptions.ConnectionError:
            # Try alternate protocol
            alt_url = injection_point['url']
            if alt_url.startswith('https://'):
                alt_url = alt_url.replace('https://', 'http://')
            else:
                alt_url = alt_url.replace('http://', 'https://')

            if injection_point['type'] == 'GET':
                parsed_url = urllib.parse.urlparse(alt_url)
                params = urllib.parse.parse_qs(parsed_url.query)
                params[injection_point['parameter']] = [payload]

                new_query = urllib.parse.urlencode(params, doseq=True)
                new_url = urllib.parse.urlunparse((
                    parsed_url.scheme, parsed_url.netloc, parsed_url.path,
                    parsed_url.params, new_query, parsed_url.fragment
                ))

                return self.session.get(new_url, timeout=self.timeout, allow_redirects=allow_redirects)
            else:
                data = {injection_point['parameter']: payload}
                return self.session.post(alt_url, data=data, timeout=self.timeout, allow_redirects=allow_redirects)

    def _detect_sql_errors(self, response_text):
        """Detect SQL error patterns in response"""
        sql_errors = [
            'sql syntax', 'mysql_fetch', 'ORA-', 'Microsoft OLE DB',
            'SQLite/JDBCDriver', 'PostgreSQL query failed', 'Warning: mysql_',
            'valid MySQL result', 'MySqlClient.', 'com.mysql.jdbc',
            'Zend_Db_Adapter', 'Pdo_Mysql', 'SQLite3::',
            'SQLException', 'mysql error', 'quoted string not properly terminated',
            'syntax error', 'database error'
        ]

        response_lower = response_text.lower()
        return any(error.lower() in response_lower for error in sql_errors)

    def _is_xss_escaped(self, response_text, payload):
        """Check if XSS payload is properly escaped"""
        escaped_chars = ['&lt;', '&gt;', '&quot;', '&#x27;', '&#x2F;', '&amp;']
        return any(escaped in response_text for escaped in escaped_chars)

    def _detect_command_output(self, response_text):
        """Detect command output patterns"""
        command_indicators = [
            'root:x:', 'bin/bash', 'drwxr-xr-x', 'total ',
            'uid=', 'gid=', 'groups=', 'PING ', 'bytes from',
            'directory of', 'volume in drive'
        ]

        return any(indicator in response_text for indicator in command_indicators)
